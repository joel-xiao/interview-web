### 大屏低代码设计

首先我先讲一下背景，因为我们的这个 APM 项目 是 toB 的吗 ，然后 做的这些项目都是 像一些 银行】股市、保险这一类的公司，他们领导呢肯定不会关注这些系统，他们只想看总览。你想我们的目标客户大概在 200-300 个，几乎每个客户都需要这种大屏展示，但是他们的需求确有非常定制化，所以我们就做了这个大屏低代码平台，这个低代码平台和业务是紧密相关的。

现在我来说一下这个设计，
先说 数据格式, 大屏最终会使用 JSON 格式 进行保存，其中有一个 nodes 集合就是 对应的组件 的简易版ast。

整体设计思路 是以 schema 驱动 组件（如 echarts 的 饼图、柱状图、曲线图，和其他的自定义业务组件如 装饰、视频组件、地图编辑器、拓扑编辑器 等）。
我们首先使用 组件schema 关联图表组件和属性 schema， 属性的 schema 的定义就是比如标题、图例、文本相关的属性、图片、layout 等。
这样的好处就是我们在新增图表组件的时候 就不需要单独去写 属性面板组件.

在设计这个架构的时候 我们是同 import.meta.globEager 进行批量注册。

好现在我以设计模式来解析这个设计的核心
比如我新创建了一个大屏、这时候其实我是需要他的上下文的 所以我就是用来 单例模式 创建一次 全局访问 去管理他的 schema 组件创建， 组件属性动态更新，确保是同一个实例对象。
其次就是组件的创建，使用了工厂模式 去创建定义好的sfc组件。如我基于 createVNode 的二次封装集成业务组件创建, 这个方式的创建实际上我是参考了 React 的 useContext 的部分设计思想，但不完全等于 useContext。
在往深处我就是 封装了一堆 hook + 上下文的概念， 比如 拖拽、成组、快捷键、标尺,组件创建、复制 还有一些其他的工具类等， 当初就是因为使用 props 和 emit 传参他复杂了 这种程序上下文链会非常长很难维护就想到了这个策略。
后面就是 我们的属性渲染面板部分，在这里我使用了 代理模式 proxy get 和 set 进行属性的变化和更新 然后操作 hook 封装好的 方法。

数据源的封装 我们在 组件属性中增加了 datasource 和 databind 概念 进行数据源的管理操作和绑定操作， 然后 通过 数据源处理中心集中发送请求返回数据 然后 更新 图表组件数据进行渲染。

在这期间其实这个编辑器遇到过一些性能问题， preview 下 就是组件创建的多的时候 会卡顿，我们最初设计的时候没有考虑这些，schema 和 组件 一次性注册的，所以后来我们做了懒加载的处理，动态加载创建组件。我的思路是这样的 我增加了一层容器 概念 首先渲染的时候 不全部注册组件和 schema, 首先渲染 layout 这个时候其实就是就用到装饰器模式了， 然后再通过 node 的 ast 结构进行 动态渲染 对应的组件实例，在性能上有很大的提升。

再一个方方面就是 组件实例的创建 最初我们使用的是 createApp 我把他改成了 createVnode创建 这样其实性能提升是非常大的，主要是体现在组件重复注入的问题上。

包括后面我们 大屏数据实时更新时 出现过大屏内存泄露 ，我当时 是 通过 浏览器的 控制台的 堆内存快照解决的 他可以分析 event事件调用以及回收情况 js 堆、css、以及 dom 创建等等内存使用情况，最终我定舞蹈的地方是 v-if 和 event 事件 没有精确回收导致的内存泄露、其实他还有一个泄露就是 axios 出现的 他的请求会话没有自动释放 一直在累加，这个当时很奇怪，他这个官方库给的是 请求后是会进行自动释放的，我后来为了解决这个问题 就对他进行了改造 封装了一层自动回收逻辑 我就是 在他返回成功或失败的时候手动给他删除掉 我当时是使用的 weakmap 存储新的对象实例然后完成后删除这个引用及axios 进行回收。


### React
React Fiber
其实讲起这个 fiber 就得从他这个调度的设计思想讲起，fiber 是一个链路的 执行节点，他把 render 比较长的内容分成多个 fiber 分步执行。并发概念， 他可以被暂停终止，在他上层是有一个调度器去管理，比如说我有一个高优先级的任务和低优先级的任务 他通过 lang 通道进行任务调度，如果在下一个 fiber 前发现了高的任务就暂停然后执行这个任务完成后继续执行 fiber 节点直到完成。


React Hooks

我用到的 hook 有 useState、 useEffect、 useLayoutEffect、 useCalback、 useMemo 、 useContext 、 usereducr 

首先他其实就是一个概念，然后 使用 hook 的方式去规范了这个语法使用， 然后我其实当时挺好奇这个 useState 是怎么和当前实例进行绑定的，怎直到是哪个实例。
我了解之后发现它这个设计挺牛的，他在执行这个 fiber 树的时候 会有一个指针状态、这个指针状态 当他执行下一个 fiber 的时候 这个指针就会指向 fiber 然后再去 use 的时候 就读取支个只针对 fiber 进行绑定。他和 vue 的相应设计非常相似， vue 是使用的 proxy get 去收集的嘛。


React Redux


### 设计模式
单列模式、工厂模式、代理模式、观察者模式、装饰器模式、策略模式（我是用在了单位转换和数据格式转换（数组、对象、等））



### 工程化
#### 请讲一下 webpack rouup vite
 css-loader 、less-loader 、vue-sfc chunks  tree-shaking 等 webpack 钩子等
#### 你知道 babel 吗

Babel 是什么 ，他主要是解决 转义的问题 如 es2025～es6 语法转 es5 语法 处理兼容问题等。

补充：
主要是 使用 AST 抽象树, 首先对 vue、jsx、css、sfc 进行解析成 AST， 然后通过这个抽象树 去把一些 箭头函数啦、includes方法啦转译成低版本支持的语法抽象树 然后再转成可执行的解释型语言 JavaScript。
包括我们 tree-shaking、chunks 都会通过AST抽象树进行处理。
webpack 他会有自己的钩子 在这个狗子期间做你自己要做的事情。





