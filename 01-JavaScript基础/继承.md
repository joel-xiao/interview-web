# JavaScript 继承机制

> JavaScript 继承方式详解：从原型链到 ES6 class

---

## 📚 目录

- [一、继承方式概览](#一继承方式概览)
- [二、原型链继承](#二原型链继承)
- [三、构造函数继承](#三构造函数继承)
- [四、组合继承](#四组合继承)
- [五、寄生组合继承](#五寄生组合继承)
- [六、ES6 class 继承](#六es6-class-继承)
- [七、继承方式对比](#七继承方式对比)

---

## 一、继承方式概览

### 1.1 继承方式全景图

```
继承方式
│
├── 1. 原型链继承
│     ├─ 实现：Child.prototype = new Parent()
│     ├─ 优点：继承父类原型方法
│     └─ 缺点：无法传参、引用类型共享
│
├── 2. 构造函数继承（借用构造函数）
│     ├─ 实现：Parent.call(this, args)
│     ├─ 优点：可以传参，避免引用类型共享
│     └─ 缺点：无法继承父类原型方法
│
├── 3. 组合继承（原型链 + 构造函数）
│     ├─ 实现：Parent.call(this) + Child.prototype = new Parent()
│     ├─ 优点：可传参、可继承原型方法
│     └─ 缺点：父构造函数调用两次
│
├── 4. 寄生组合继承（最优 ES5 方案）
│     ├─ 实现：Parent.call(this) + Child.prototype = Object.create(Parent.prototype)
│     ├─ 优点：解决组合继承的缺点
│     └─ 缺点：代码较复杂
│
└── 5. ES6 class 继承
      ├─ 实现：class Child extends Parent { super(); }
      ├─ 优点：语法清晰、官方推荐
      └─ 本质：语法糖，底层仍是原型链 + 构造函数
```

### 1.2 关系总结

1. **原型链继承** → 继承方法
2. **构造函数继承** → 继承属性
3. **组合继承** → 属性 + 方法都继承（最常用 ES5 手写方式）
4. **寄生组合继承** → 组合继承的优化版（最优 ES5 方案）
5. **ES6 class** → 语法糖封装组合继承，推荐实际开发使用

---

## 二、原型链继承

### 2.1 实现方式

```js
function Parent() {
  this.name = 'parent';
  this.colors = ['red', 'blue'];
}

Parent.prototype.say = function() {
  console.log(this.name);
};

function Child() {
  this.type = 'child';
}

// 核心：子类原型指向父类实例
Child.prototype = new Parent();
Child.prototype.constructor = Child;

const child1 = new Child();
const child2 = new Child();

child1.say(); // 'parent'
child1.colors.push('green');
console.log(child2.colors); // ['red', 'blue', 'green'] - 引用类型共享！
```

### 2.2 优点

- ✅ 可以继承父类的原型方法和属性

### 2.3 缺点

- ❌ **无法传参**：无法向父类构造函数传递参数
- ❌ **引用类型共享**：所有子类实例共享父类实例的引用类型属性
- ❌ **无法多继承**：只能继承一个父类

### 2.4 问题示例

```js
// 问题1：无法传参
function Parent(name) {
  this.name = name; // 无法传递 name
}

// 问题2：引用类型共享
child1.colors.push('green');
console.log(child2.colors); // 也被修改了！
```

---

## 三、构造函数继承

### 3.1 实现方式

```js
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue'];
}

Parent.prototype.say = function() {
  console.log(this.name);
};

function Child(name, age) {
  // 核心：在子类构造函数中调用父类构造函数
  Parent.call(this, name);
  this.age = age;
}

const child1 = new Child('child1', 10);
const child2 = new Child('child2', 20);

child1.colors.push('green');
console.log(child2.colors); // ['red', 'blue'] - 不共享！

// child1.say(); // 报错！无法访问父类原型方法
```

### 3.2 优点

- ✅ **可以传参**：可以向父类构造函数传递参数
- ✅ **避免引用类型共享**：每个子类实例都有独立的属性副本

### 3.3 缺点

- ❌ **无法继承原型方法**：只能继承父类实例属性，无法继承原型方法
- ❌ **方法无法复用**：每个子类实例都会创建新的方法副本（如果方法定义在构造函数中）

---

## 四、组合继承

### 4.1 实现方式

```js
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue'];
}

Parent.prototype.say = function() {
  console.log(this.name);
};

function Child(name, age) {
  // 1. 构造函数继承：继承实例属性
  Parent.call(this, name);
  this.age = age;
}

// 2. 原型链继承：继承原型方法
Child.prototype = new Parent();
Child.prototype.constructor = Child;

const child1 = new Child('child1', 10);
const child2 = new Child('child2', 20);

child1.say(); // 'child1' ✅
child1.colors.push('green');
console.log(child2.colors); // ['red', 'blue'] ✅
```

### 4.2 优点

- ✅ **可以传参**：可以向父类构造函数传递参数
- ✅ **可以继承原型方法**：可以访问父类原型上的方法
- ✅ **避免引用类型共享**：每个实例有独立的属性

### 4.3 缺点

- ❌ **父构造函数调用两次**：
  - 一次在 `Parent.call(this, name)`（子类实例属性）
  - 一次在 `Child.prototype = new Parent()`（子类原型）
- ❌ **性能问题**：父类实例属性在子类原型上重复创建

---

## 五、寄生组合继承

### 5.1 实现方式（最优 ES5 方案）

```js
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'blue'];
}

Parent.prototype.say = function() {
  console.log(this.name);
};

function Child(name, age) {
  // 1. 构造函数继承：继承实例属性
  Parent.call(this, name);
  this.age = age;
}

// 2. 寄生组合：使用 Object.create 创建原型链
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

const child1 = new Child('child1', 10);
const child2 = new Child('child2', 20);

child1.say(); // 'child1' ✅
child1.colors.push('green');
console.log(child2.colors); // ['red', 'blue'] ✅
```

### 5.2 核心改进

**使用 `Object.create` 替代 `new Parent()`**：

```js
// 组合继承（有问题）
Child.prototype = new Parent(); // 调用父构造函数，创建不必要的实例属性

// 寄生组合继承（优化）
Child.prototype = Object.create(Parent.prototype); // 只创建原型链，不调用构造函数
```

### 5.3 优点

- ✅ **解决组合继承的缺点**：父构造函数只调用一次
- ✅ **性能优化**：子类原型上不会有多余的父类实例属性
- ✅ **完美继承**：可以传参、可以继承原型方法、避免引用类型共享

### 5.4 完整实现（考虑边界情况）

```js
function inherit(Child, Parent) {
  // 创建父类原型的副本
  const prototype = Object.create(Parent.prototype);
  // 修正 constructor 指向
  prototype.constructor = Child;
  // 将副本赋值给子类原型
  Child.prototype = prototype;
}

// 使用
inherit(Child, Parent);
```

---

## 六、ES6 class 继承

### 6.1 实现方式

```js
class Parent {
  constructor(name) {
    this.name = name;
    this.colors = ['red', 'blue'];
  }
  
  say() {
    console.log(this.name);
  }
}

class Child extends Parent {
  constructor(name, age) {
    // 必须调用 super，相当于 Parent.call(this, name)
    super(name);
    this.age = age;
  }
}

const child1 = new Child('child1', 10);
const child2 = new Child('child2', 20);

child1.say(); // 'child1' ✅
child1.colors.push('green');
console.log(child2.colors); // ['red', 'blue'] ✅
```

### 6.2 核心特性

#### super 关键字

```js
class Child extends Parent {
  constructor(name, age) {
    super(name); // 调用父类构造函数
    this.age = age;
  }
  
  say() {
    super.say(); // 调用父类方法
    console.log('child say');
  }
}
```

#### 静态方法继承

```js
class Parent {
  static staticMethod() {
    return 'parent static';
  }
}

class Child extends Parent {
  static staticMethod() {
    return super.staticMethod() + ' -> child static';
  }
}

Child.staticMethod(); // 'parent static -> child static'
```

### 6.3 本质

**ES6 class 只是语法糖，底层实现仍是原型链 + 构造函数**：

```js
// ES6 class
class Child extends Parent {
  constructor(name) {
    super(name);
  }
}

// 等价于 ES5（简化版）
function Child(name) {
  Parent.call(this, name);
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
```

### 6.4 优点

- ✅ **语法清晰**：代码更易读易写
- ✅ **官方推荐**：ES6 标准，未来趋势
- ✅ **功能完整**：支持 super、静态方法、getter/setter

### 6.5 面试重点

1. **class 是语法糖**：底层仍是原型链 + 构造函数
2. **super 的作用**：
   - 在构造函数中：调用父类构造函数
   - 在方法中：调用父类方法
3. **extends 的实现**：等价于寄生组合继承

---

## 七、继承方式对比

| 继承方式 | 传参 | 继承原型方法 | 引用类型共享 | 父构造函数调用次数 | 推荐度 |
|---------|------|------------|------------|----------------|--------|
| **原型链继承** | ❌ | ✅ | ❌（共享） | 1次 | ⭐⭐ |
| **构造函数继承** | ✅ | ❌ | ✅（不共享） | 1次 | ⭐⭐ |
| **组合继承** | ✅ | ✅ | ✅（不共享） | 2次 | ⭐⭐⭐ |
| **寄生组合继承** | ✅ | ✅ | ✅（不共享） | 1次 | ⭐⭐⭐⭐⭐ |
| **ES6 class** | ✅ | ✅ | ✅（不共享） | 1次 | ⭐⭐⭐⭐⭐ |

---

## 🎯 学习建议

1. **理解原理**：掌握每种继承方式的实现原理
2. **对比分析**：理解各方式的优缺点
3. **实际应用**：新项目优先使用 ES6 class
4. **面试准备**：重点掌握寄生组合继承和 ES6 class

---

## 📖 相关资源

- [MDN: 继承与原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
- [MDN: class](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes)

---

**相关文件**：
- [JavaScript基础.md](./JavaScript基础.md) - JavaScript 基础
- [JavaScript常见坑点.md](./JavaScript常见坑点.md) - JavaScript 常见坑点
