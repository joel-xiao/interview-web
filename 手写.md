
## **1️⃣ 数组相关手写题**

1. **手写 `Array.prototype.map`**

```js
Array.prototype.myMap = function(fn, thisArg) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    if (i in this) {
      result.push(fn.call(thisArg, this[i], i, this));
    }
  }
  return result;
};
```

2. **手写 `Array.prototype.filter`**

```js
Array.prototype.myFilter = function(fn, thisArg) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    if (i in this && fn.call(thisArg, this[i], i, this)) {
      result.push(this[i]);
    }
  }
  return result;
};
```

3. **手写 `Array.prototype.reduce`**

```js
Array.prototype.myReduce = function(fn, initial) {
  let accumulator = initial === undefined ? this[0] : initial;
  let start = initial === undefined ? 1 : 0;
  for (let i = start; i < this.length; i++) {
    if (i in this) {
      accumulator = fn(accumulator, this[i], i, this);
    }
  }
  return accumulator;
};
```

---

## **2️⃣ 函数相关手写题**

1. **手写 `call`**

```js
Function.prototype.myCall = function(context, ...args) {
  context = context || globalThis;
  const fnSymbol = Symbol();
  context[fnSymbol] = this;
  const result = context[fnSymbol](...args);
  delete context[fnSymbol];
  return result;
};
```

2. **手写 `apply`**

```js
Function.prototype.myApply = function(context, args) {
  context = context || globalThis;
  const fnSymbol = Symbol();
  context[fnSymbol] = this;
  const result = context[fnSymbol](...args);
  delete context[fnSymbol];
  return result;
};
```

3. **手写 `bind`**

```js
Function.prototype.myBind = function(context, ...args1) {
  const self = this;
  return function(...args2) {
    return self.apply(this instanceof self ? this : context, [...args1, ...args2]);
  };
};
```

4. **手写节流 throttle**

```js
function throttle(fn, delay) {
  let last = 0;
  return function(...args) {
    const now = Date.now();
    if (now - last > delay) {
      last = now;
      fn.apply(this, args);
    }
  };
}
```

5. **手写防抖 debounce**

```js
function debounce(fn, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

---

## **3️⃣ 深浅拷贝**

1. **浅拷贝**

```js
function shallowCopy(obj) {
  if (typeof obj !== 'object' || obj === null) return obj;
  const result = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) result[key] = obj[key];
  }
  return result;
}
```

2. **深拷贝（支持循环引用）**

```js
function deepClone(obj, map = new WeakMap()) {
  if (typeof obj !== 'object' || obj === null) return obj;
  if (map.has(obj)) return map.get(obj);
  const result = Array.isArray(obj) ? [] : {};
  map.set(obj, result);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[key], map);
    }
  }
  return result;
}
```

---

## **4️⃣ 继承**

1. **原型链继承**

```js
function Parent() { this.name = 'parent'; }
Parent.prototype.say = function() { console.log(this.name); }

function Child() {}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
```

2. **组合继承（面试推荐）**

```js
function Parent(name) { this.name = name; }
Parent.prototype.say = function() { console.log(this.name); }

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
```

---

## **5️⃣ 模块化手写题**

1. **CommonJS 模块**

```js
// math.js
module.exports.add = (a,b) => a+b;

// index.js
const math = require('./math');
console.log(math.add(1,2));
```

2. **ESM 模块**

```js
// math.js
export function add(a,b){ return a+b; }

// index.js
import { add } from './math.js';
console.log(add(1,2));
```

---

## **6️⃣ 其他高频手写题**

* **事件总线 / 发布订阅**

```js
class EventEmitter {
  constructor() { this.events = {}; }
  on(event, fn) { (this.events[event] ||= []).push(fn); }
  emit(event, ...args) { (this.events[event] || []).forEach(fn => fn(...args)); }
  off(event, fn) { this.events[event] = (this.events[event] || []).filter(f => f !== fn); }
}
```

* **手写 instanceof**

```js
function myInstanceof(left, right) {
  let proto = Object.getPrototypeOf(left);
  while(proto) {
    if (proto === right.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```

* **手写 new**

```js
function myNew(fn, ...args) {
  const obj = {};
  Object.setPrototypeOf(obj, fn.prototype);
  const result = fn.apply(obj, args);
  return typeof result === 'object' && result !== null ? result : obj;
}
```

---
