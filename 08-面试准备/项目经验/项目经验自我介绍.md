# 项目经验自我介绍

> 大屏低代码编辑平台项目经验的口语化自我介绍版本，适合面试场景

**文件位置**：`08-面试准备/项目经验/项目经验自我介绍.md`

**相关文档**：
- [大屏低代码编辑.md](./大屏低代码编辑.md) - 详细项目经验文档
- [项目架构设计.md](./项目架构设计.md) - 技术架构设计文档

---

## 📝 自我介绍模板（3-5分钟版本）

### 开场介绍

**面试官您好，我想介绍一下我负责的大屏低代码编辑平台项目。**

这是一个面向企业级数据可视化的低代码编辑平台，主要解决传统大屏开发成本高、周期长的问题。平台支持拖拽式配置、实时预览、多数据源接入，让业务人员可以通过零代码的方式快速搭建数据大屏。

---

### 一、项目背景与技术选型

**首先说一下项目背景。**

这个项目是我们公司内部的数据可视化平台，主要服务于业务部门的数据展示需求。传统的大屏开发方式，每个大屏都需要前端开发人员从零开始写代码，开发周期长、成本高，而且维护困难。

**所以我设计了这个低代码平台，核心思路是：**
- 通过 Schema 驱动的方式，用 JSON 配置来定义组件结构
- 采用组件化开发，将通用组件和业务组件分离
- 实现配置化开发，让业务人员通过可视化编辑器就能搭建大屏

**技术选型方面：**
- 前端框架用的是 Vue3，主要看中它的 Composition API 和性能优势
- 状态管理用的是 Vuex，统一管理全局状态
- 构建工具用的是 Vite，开发体验和构建速度都很好
- 可视化库用的是 ECharts、Three.js 这些成熟的库

---

### 二、核心架构设计

**架构设计这块，我采用了分层架构 + Schema 驱动 + 组件化的方案。**

#### 1. 整体架构分层

我把整个系统分成了四层：

**第一层是表现层**，包括编辑器界面、场景渲染、预览模式。编辑器负责可视化编辑，场景渲染负责大屏展示。

**第二层是业务层**，这是核心层，包括：
- **Dashboard 核心类**：统一管理大屏生命周期、组件注册、场景加载
- **组件系统**：通用组件和业务组件分离
- **Schema 系统**：通过 JSON Schema 定义组件配置结构

**第三层是数据层**，包括：
- **数据源管理**：支持多数据源接入，比如应用数据、主机数据、网络数据
- **服务层**：统一封装所有接口请求，统一错误处理
- **状态管理**：用 Vuex 管理全局状态，保障跨组件、跨页面状态同步

**第四层是支撑层**，包括工具函数库、通用组件库、插件机制。

#### 2. Schema 驱动架构

**Schema 驱动是这个项目的核心亮点。**

我设计了一个 Schema 注册中心，每个组件都有自己的 Schema 定义。Schema 定义了组件的所有可配置属性，包括布局、样式、数据绑定等。

**这样做的好处是：**
- 编辑器可以根据 Schema 动态生成配置面板，不需要为每个组件单独写配置界面
- 新增组件只需要添加 Schema 定义，就能自动支持配置化
- Schema 验证可以确保配置的正确性，减少错误

**举个例子：**
比如一个柱状图组件，它的 Schema 定义了布局、标题、外观、数据源等配置项。用户在编辑器中选中这个组件，属性面板就会根据 Schema 自动生成对应的配置表单。

#### 3. 组件系统设计

**组件这块，我做了三层分类：**

**L1 是基础组件**，比如柱状图、折线图、饼图这些，单一功能，没有业务逻辑。

**L2 是容器组件**，比如边框容器、网格容器，主要负责布局和嵌套。

**L3 是业务组件**，比如地图编辑器、拓扑编辑器，这些组件业务逻辑比较复杂，还包含独立的编辑器功能。

**组件注册机制：**
我实现了一个自动注册机制，通过 `import.meta.globEager` 批量加载组件，然后自动注册到 Vue 组件系统中。这样新增组件只需要在对应目录下创建文件，就能自动被识别和注册。

---

### 三、设计模式应用

**在设计模式这块，我应用了多种设计模式来解决实际问题：**

#### 1. 单例模式
**应用场景**：Dashboard 核心类采用单例模式，确保全局只有一个实例，统一管理大屏生命周期。

#### 2. 工厂模式
**应用场景**：组件创建统一通过工厂方法 `createAppComponent()`，根据 Schema 配置动态创建组件实例。这样统一了组件创建入口，降低了创建复杂度。

#### 3. 观察者模式
**应用场景**：组件状态变更、交互操作的实时响应。比如一个组件的数据更新了，其他依赖这个数据的组件可以自动响应更新。

#### 4. 代理模式
**应用场景**：组件属性代理与更新拦截。通过 Proxy 拦截属性更新，实现属性变更的统一管理，减少不必要的渲染。

#### 5. 装饰器模式
**应用场景**：重点用在 Layout 渲染上。我封装了装饰器组件，负责布局嵌套、样式统一、容器适配等逻辑，不侵入业务组件代码，有效降低了布局与业务的耦合度。

#### 6. 适配器模式
**应用场景**：数据源适配。因为要接入多个数据源，每个数据源的格式可能不一样，我通过适配器模式实现数据格式转换和字段映射，统一数据接口。

---

### 四、数据处理方案

**数据处理这块，我设计了一个统一的数据源管理方案。**

#### 1. 统一配置方式
每个组件通过 `datasource` 属性配置数据源，通过 `databind` 属性完成字段映射绑定。

#### 2. 适配器模式解决多源数据问题
**遇到的问题：**
- 不同数据源的格式不一样，比如有的返回数组，有的返回对象
- 指标字段口径不一致，比如有的叫 `value`，有的叫 `count`

**解决方案：**
我实现了一个数据适配器，在数据源和组件之间做了一层转换。适配器负责：
- 数据格式转换：将不同格式的数据统一转换成组件需要的格式
- 字段映射：根据 `databind` 配置，将源字段映射到目标字段
- 数据清洗：过滤无效数据，处理异常值

**效果：**
这样组件就不需要关心数据来源，只需要按照统一的格式接收数据，实现了多源数据的无缝适配。

---

### 五、性能优化

**性能优化这块，我做了三个方面的优化：**

#### 1. 渲染逻辑轻量化
**优化前**：使用 `createApp` 创建完整的 Vue 应用实例，每个组件都是一个完整的应用，内存占用大。

**优化后**：改用 `createVNode` 轻量级渲染，只创建必要的虚拟节点，不创建完整的应用实例。

**效果：**
- 渲染性能提升 30%+
- 内存占用降低 40%+
- 首屏加载时间减少 20%+

#### 2. 懒加载策略
**实现方案：**
- 使用 `import.meta.globEager` 批量加载组件（构建时）
- 使用动态 `import()` 实现运行时按需加载
- 遵循「先框架后内容」原则，优先加载整体布局框架，再按需加载组件资源

**加载策略：**
- **首屏加载**：只加载布局框架和核心组件（图表、容器）
- **按需加载**：业务组件（地图、拓扑、3D）在用户操作时再加载
- **预加载**：预加载用户可能访问的组件

**效果：**
- 首屏加载时间减少 50%+
- 按需加载资源，降低初始包体积
- 优化用户体验，提升交互流畅度

#### 3. 属性更新管控
通过代理模式实现属性更新拦截，只更新真正变化的组件，减少不必要的渲染。

**全链路性能调优：**
从渲染、加载、状态、数据四个维度实现全链路优化，全方位保障平台高效稳定运行。

---

### 六、工程化架构分层

**工程化这块，我做了清晰的分层设计：**

#### 1. 组件层
**通用组件**：全项目复用，与业务无关，比如基础图表、容器组件、UI 组件。

**业务组件**：大屏场景专属，贴合业务需求，比如地图编辑器、拓扑编辑器、3D 组件。

#### 2. 核心支撑层
- **Store**：统一管理全局状态，保障跨组件、跨页面状态同步
- **Service 层**：封装所有接口请求，统一请求拦截、响应处理与异常兜底
- **Util 工具库**：整合通用方法，提升开发效率
- **插件机制**：实现功能的灵活插拔与按需扩展

**这样设计的好处：**
- 高内聚低耦合：每层职责明确，互不干扰
- 易于维护：代码结构清晰，便于理解和维护
- 易于扩展：新增功能只需要在对应层添加代码

---

### 七、项目成果

**最后说一下项目成果：**

#### 技术成果
1. **扩展性**：
   - 插件机制支持功能灵活扩展
   - 组件化架构支持快速新增组件
   - Schema 驱动支持配置化扩展

2. **可维护性**：
   - 清晰分层架构，职责明确
   - 代码结构规范，易于理解
   - 完善的文档和注释

3. **性能优化**：
   - 首屏加载时间减少 50%+
   - 渲染性能提升 30%+
   - 内存占用降低 40%+
   - 支持大屏高负载场景稳定运行

4. **工程化**：
   - 完整的工程化体系
   - 统一的开发规范
   - 自动化构建和部署

#### 业务价值
1. **开发效率**：配置化开发，降低开发成本 60%+
2. **用户体验**：可视化编辑，零代码配置大屏
3. **可扩展性**：支持多数据源接入，灵活适配业务需求
4. **稳定性**：全链路性能优化，保障生产环境稳定运行

---

### 八、技术栈总结

**这个项目用到的核心技术：**

- **前端框架**：Vue3（Composition API + `<script setup>`）
- **状态管理**：Vuex
- **构建工具**：Vite
- **可视化库**：ECharts、Three.js、Mapbox GL

**设计模式**：
- 创建型：单例模式、工厂模式
- 结构型：代理模式、装饰器模式、适配器模式
- 行为型：观察者模式、策略模式

**架构模式**：
- 分层架构：组件层、支撑层、数据层
- 插件化架构：支持功能插件化扩展
- Schema 驱动架构：配置驱动开发

---

## 🎯 面试要点总结

### 核心亮点
1. **Schema 驱动架构**：通过 JSON Schema 实现配置化开发，降低开发成本
2. **组件化设计**：通用组件与业务组件分离，提升复用性
3. **设计模式应用**：6 种设计模式全链路应用，解决实际问题
4. **性能优化**：全链路性能优化，首屏加载时间减少 50%+
5. **工程化体系**：清晰分层架构，完整的工程化体系

### 技术深度
- **架构设计能力**：分层架构、Schema 驱动、组件化设计
- **设计模式应用**：单例、工厂、观察者、代理、装饰器、适配器
- **性能优化能力**：渲染优化、懒加载、属性更新管控
- **工程化能力**：分层架构、插件机制、统一规范

### 解决问题能力
- **多源数据适配**：适配器模式解决数据格式差异问题
- **性能优化**：渲染轻量化、懒加载策略
- **可维护性**：清晰分层架构，降低维护成本
- **可扩展性**：插件机制、组件化设计

---

## 💡 面试回答技巧

### 1. 项目背景（30秒）
- 简洁说明项目背景和解决的问题
- 突出项目的价值和意义

### 2. 技术架构（2-3分钟）
- 重点讲 Schema 驱动架构和组件化设计
- 说明分层架构的设计思路
- 突出设计模式的应用场景

### 3. 核心实现（1-2分钟）
- 重点讲数据处理方案（适配器模式）
- 说明组件系统的设计
- 突出解决的技术难点

### 4. 性能优化（1分钟）
- 说明三个优化点：渲染轻量化、懒加载、属性更新管控
- 用数据说明优化效果

### 5. 项目成果（30秒）
- 用数据说明技术成果和业务价值
- 突出项目的亮点和贡献

---

## 📌 常见面试问题准备

### Q1: 为什么选择 Schema 驱动架构？
**回答要点：**
- 配置化开发，降低开发成本
- 动态生成配置面板，提升开发效率
- 类型安全，Schema 验证确保配置正确性
- 可扩展性强，新增组件只需添加 Schema 定义

### Q2: 如何解决多源数据适配问题？
**回答要点：**
- 采用适配器模式
- 统一数据接口，屏蔽底层数据差异
- 通过 `datasource` 和 `databind` 配置数据源和字段映射
- 适配器负责格式转换、字段映射、数据清洗

### Q3: 性能优化做了哪些工作？
**回答要点：**
- 渲染轻量化：`createVNode` 替代 `createApp`
- 懒加载策略：先框架后内容，按需加载
- 属性更新管控：代理模式优化更新性能
- 全链路优化：渲染、加载、状态、数据四个维度

### Q4: 设计模式是如何应用的？
**回答要点：**
- 单例模式：Dashboard 核心类
- 工厂模式：组件创建
- 观察者模式：组件状态变更响应
- 代理模式：属性更新拦截
- 装饰器模式：Layout 渲染
- 适配器模式：数据源适配

### Q5: 组件系统是如何设计的？
**回答要点：**
- 三层分类：基础组件、容器组件、业务组件
- 自动注册机制：通过 `import.meta.globEager` 批量加载
- 通用组件与业务组件分离
- Schema 定义组件配置结构

---

## 🔗 相关文档

- [大屏低代码编辑.md](./大屏低代码编辑.md) - 详细项目经验文档
- [项目架构设计.md](./项目架构设计.md) - 技术架构设计文档

