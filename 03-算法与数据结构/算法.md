# 算法题分类汇总

> 前端面试高频算法题，按数据结构与算法类型分类

---

## 📚 目录

- [一、数组与字符串](#一数组与字符串)
- [二、链表](#二链表)
- [三、递归与树](#三递归与树)
- [四、排序与搜索](#四排序与搜索)
- [五、栈与队列](#五栈与队列)
- [六、滑动窗口](#六滑动窗口)
- [七、动态规划](#七动态规划)
- [八、贪心算法](#八贪心算法)
- [九、字符串匹配](#九字符串匹配)

---

## 一、数组与字符串

### 1.1 两数之和（Two Sum）

**题目**：给定数组 `nums` 和目标值 `target`，返回和为 target 的两个下标。

**解法**：

```js
function twoSum(nums, target) {
  const map = new Map();
  for(let i=0; i<nums.length; i++){
    const complement = target - nums[i];
    if(map.has(complement)) return [map.get(complement), i];
    map.set(nums[i], i);
  }
}
```

**思路**：用哈希表存已访问元素 → O(n) 时间复杂度

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

---

### 1.2 数组去重

**题目**：去除数组中的重复元素

**解法 1：ES6 Set**

```js
const unique = arr => [...new Set(arr)];
```

**解法 2：手写实现**

```js
function unique(arr) {
  const res = [];
  const map = {};
  for(let i of arr){
    if(!map[i]){
      res.push(i);
      map[i] = true;
    }
  }
  return res;
}
```

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

---

### 1.3 翻转字符串

**题目**：反转字符串

**解法 1：使用数组方法**

```js
function reverseStr(str) {
  return str.split('').reverse().join('');
}
```

**解法 2：循环反转**

```js
function reverseStr(str) {
  let res = '';
  for(let i=str.length-1;i>=0;i--){
    res += str[i];
  }
  return res;
}
```

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

---

## 二、链表

### 2.1 反转链表

**题目**：反转一个单链表

**解法**：

```js
function reverseList(head) {
  let prev = null, curr = head;
  while(curr){
    const next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
}
```

**思路**：使用三个指针（prev、curr、next）逐个反转

**时间复杂度**：O(n)  
**空间复杂度**：O(1)

---

### 2.2 合并两个有序链表

**题目**：将两个升序链表合并为一个新的升序链表

**解法**：

```js
function mergeTwoLists(l1, l2) {
  const dummy = new ListNode(0);
  let curr = dummy;
  while(l1 && l2){
    if(l1.val < l2.val){
      curr.next = l1;
      l1 = l1.next;
    } else {
      curr.next = l2;
      l2 = l2.next;
    }
    curr = curr.next;
  }
  curr.next = l1 || l2;
  return dummy.next;
}
```

**思路**：使用虚拟头节点，逐个比较合并

**时间复杂度**：O(n + m)  
**空间复杂度**：O(1)

---

## 三、递归与树

### 3.1 求数组全排列

**题目**：给定一个不含重复数字的数组，返回其所有可能的全排列

**解法**：

```js
function permute(arr) {
  const res = [];
  const dfs = (path, used) => {
    if(path.length === arr.length){
      res.push([...path]);
      return;
    }
    for(let i=0;i<arr.length;i++){
      if(used[i]) continue;
      used[i] = true;
      path.push(arr[i]);
      dfs(path, used);
      path.pop();
      used[i] = false;
    }
  }
  dfs([], []);
  return res;
}
```

**思路**：回溯算法，使用 DFS 遍历所有可能

**时间复杂度**：O(n × n!)  
**空间复杂度**：O(n)

---

### 3.2 二叉树遍历

#### 前序遍历

```js
function preorder(root) {
  if(!root) return [];
  return [root.val, ...preorder(root.left), ...preorder(root.right)];
}
```

#### 中序遍历

```js
function inorder(root) {
  if(!root) return [];
  return [...inorder(root.left), root.val, ...inorder(root.right)];
}
```

#### 后序遍历

```js
function postorder(root) {
  if(!root) return [];
  return [...postorder(root.left), ...postorder(root.right), root.val];
}
```

**时间复杂度**：O(n)  
**空间复杂度**：O(h)，h 为树的高度

---

## 四、排序与搜索

### 4.1 冒泡排序

**题目**：实现冒泡排序

**解法**：

```js
function bubbleSort(arr) {
  for(let i=0;i<arr.length;i++){
    for(let j=0;j<arr.length-1-i;j++){
      if(arr[j] > arr[j+1]){
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
      }
    }
  }
  return arr;
}
```

**思路**：相邻元素比较，大的往后移

**时间复杂度**：O(n²)  
**空间复杂度**：O(1)

---

### 4.2 二分查找

**题目**：在有序数组中查找目标值

**解法**：

```js
function binarySearch(arr, target) {
  let left=0, right=arr.length-1;
  while(left<=right){
    const mid = Math.floor((left+right)/2);
    if(arr[mid] === target) return mid;
    if(arr[mid] < target) left = mid + 1;
    else right = mid - 1;
  }
  return -1;
}
```

**思路**：每次缩小一半搜索范围

**时间复杂度**：O(log n)  
**空间复杂度**：O(1)

---

## 五、栈与队列

### 5.1 有效括号匹配

**题目**：判断字符串中的括号是否有效匹配

**解法**：

```js
function isValid(s) {
  const stack = [];
  const map = { '(':')', '[':']', '{':'}' };
  for(let c of s){
    if(map[c]){
      stack.push(c);
    } else {
      if(c !== map[stack.pop()]) return false;
    }
  }
  return stack.length === 0;
}
```

**思路**：使用栈保存未匹配的左括号

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

---

### 5.2 最小栈

**题目**：设计一个支持 push、pop、top 操作，并能在常数时间内检索到最小元素的栈

**解法**：

```js
class MinStack {
  constructor() {
    this.stack = [];
    this.minStack = [];
  }
  push(val) {
    this.stack.push(val);
    if(!this.minStack.length || val <= this.minStack[this.minStack.length-1]) {
      this.minStack.push(val);
    }
  }
  pop() {
    const val = this.stack.pop();
    if(val === this.minStack[this.minStack.length-1]) this.minStack.pop();
    return val;
  }
  top() { return this.stack[this.stack.length-1]; }
  getMin() { return this.minStack[this.minStack.length-1]; }
}
```

**思路**：使用辅助栈保存最小值

**时间复杂度**：O(1)（所有操作）  
**空间复杂度**：O(n)

---

## 六、滑动窗口

### 6.1 最大子数组和（长度 k）

**题目**：给定数组和长度 k，求长度为 k 的子数组的最大和

**解法**：

```js
function maxSumK(arr, k) {
  let sum = 0, max = -Infinity;
  for(let i=0;i<k;i++) sum += arr[i];
  max = sum;
  for(let i=k;i<arr.length;i++){
    sum = sum - arr[i-k] + arr[i];
    max = Math.max(max, sum);
  }
  return max;
}
```

**思路**：滑动窗口，每次移动窗口时更新和

**时间复杂度**：O(n)  
**空间复杂度**：O(1)

---

### 6.2 无重复字符的最长子串

**题目**：给定一个字符串，找出不含有重复字符的最长子串的长度

**解法**：

```js
function lengthOfLongestSubstring(s) {
  const set = new Set();
  let left=0, maxLen=0;
  for(let right=0; right<s.length; right++){
    while(set.has(s[right])){
      set.delete(s[left++]);
    }
    set.add(s[right]);
    maxLen = Math.max(maxLen, right-left+1);
  }
  return maxLen;
}
```

**思路**：滑动窗口 + Set，维护无重复字符的窗口

**时间复杂度**：O(n)  
**空间复杂度**：O(min(n, m))，m 为字符集大小

---

## 七、动态规划

### 7.1 爬楼梯

**题目**：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。有多少种不同的方法可以爬到楼顶？

**解法**：

```js
function climbStairs(n) {
  if(n<=2) return n;
  let a=1, b=2;
  for(let i=3;i<=n;i++){
    [a,b] = [b,a+b];
  }
  return b;
}
```

**思路**：DP 状态转移方程：f(n) = f(n-1) + f(n-2)

**时间复杂度**：O(n)  
**空间复杂度**：O(1)

---

### 7.2 最大子序和

**题目**：给定一个整数数组，找到一个具有最大和的连续子数组

**解法**：

```js
function maxSubArray(nums) {
  let maxSum = nums[0], currSum = nums[0];
  for(let i=1;i<nums.length;i++){
    currSum = Math.max(nums[i], currSum+nums[i]);
    maxSum = Math.max(maxSum, currSum);
  }
  return maxSum;
}
```

**思路**：Kadane 算法，维护当前最大和

**时间复杂度**：O(n)  
**空间复杂度**：O(1)

---

### 7.3 编辑距离

**题目**：给定两个单词 word1 和 word2，返回将 word1 转换成 word2 所使用的最少操作数

**解法**：

```js
function minDistance(word1, word2) {
  const m = word1.length, n = word2.length;
  const dp = Array.from({length:m+1}, () => Array(n+1).fill(0));
  for(let i=0;i<=m;i++) dp[i][0] = i;
  for(let j=0;j<=n;j++) dp[0][j] = j;

  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      if(word1[i-1]===word2[j-1]) {
        dp[i][j]=dp[i-1][j-1];
      } else {
        dp[i][j]=1+Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);
      }
    }
  }
  return dp[m][n];
}
```

**思路**：DP，dp[i][j] 表示 word1[0..i] 到 word2[0..j] 的最小编辑距离

**时间复杂度**：O(m × n)  
**空间复杂度**：O(m × n)

---

## 八、贪心算法

### 8.1 分发饼干

**题目**：给孩子饼干，使尽量多的孩子满足

**解法**：

```js
function findContentChildren(g, s) {
  g.sort((a, b) => a - b);
  s.sort((a, b) => a - b);

  let i = 0; // 指向孩子
  let j = 0; // 指向饼干
  let count = 0;

  while (i < g.length && j < s.length) {
    if (s[j] >= g[i]) {
      count++;
      i++;
      j++;
    } else {
      j++;
    }
  }

  return count;
}
```

**思路**：贪心策略，先满足胃口小的孩子

**时间复杂度**：O(n log n)  
**空间复杂度**：O(1)

---

### 8.2 会议室问题

**题目**：给定会议时间，计算最少会议室数量

**解法**：

```js
function minMeetingRooms(intervals) {
  const starts = intervals.map(i => i[0]).sort((a,b)=>a-b);
  const ends = intervals.map(i => i[1]).sort((a,b)=>a-b);

  let rooms = 0;
  let endPtr = 0;

  for (let i = 0; i < starts.length; i++) {
    if (starts[i] < ends[endPtr]) {
      rooms++; // 需要新会议室
    } else {
      endPtr++; // 复用会议室
    }
  }

  return rooms;
}
```

**思路**：贪心策略，按开始时间排序，使用最早结束的会议室

**时间复杂度**：O(n log n)  
**空间复杂度**：O(n)

---

## 九、字符串匹配

### 9.1 最小覆盖子串

**题目**：给定字符串 s 和 t，找到 s 中包含 t 所有字符的最短子串

**解法**：

```js
function minWindow(s, t) {
  const need = new Map();
  for(let c of t) need.set(c, (need.get(c)||0)+1);
  let left=0,right=0,count=t.length,minLen=Infinity,start=0;

  while(right<s.length){
    const c = s[right];
    if(need.has(c) && need.get(c)>0) count--;
    if(need.has(c)) need.set(c, need.get(c)-1);
    right++;
    while(count===0){
      if(right-left<minLen){ minLen = right-left; start = left; }
      const d = s[left];
      if(need.has(d)) need.set(d, need.get(d)+1);
      if(need.has(d) && need.get(d)>0) count++;
      left++;
    }
  }
  return minLen===Infinity ? '' : s.substr(start, minLen);
}
```

**思路**：滑动窗口 + 哈希表，维护包含 t 所有字符的窗口

**时间复杂度**：O(|s| + |t|)  
**空间复杂度**：O(|s| + |t|)

---

## 🎯 复习总结

### 按数据结构分类

1. **数组 & 字符串**：两数之和、翻转、去重、滑动窗口
2. **链表**：反转、合并、环检测
3. **树 & 递归**：前/中/后序遍历、全排列、子集
4. **栈 & 队列**：括号匹配、最小栈、实现栈队列

### 按算法类型分类

1. **排序与搜索**：冒泡排序、二分查找
2. **滑动窗口**：最大子数组和、无重复字符最长子串
3. **动态规划**：爬楼梯、最大子序和、编辑距离
4. **贪心算法**：分发饼干、会议室问题
5. **字符串匹配**：最小覆盖子串

---

## 📊 复杂度总结

| 算法类型 | 时间复杂度 | 空间复杂度 | 典型题目 |
|---------|-----------|-----------|---------|
| **哈希表** | O(n) | O(n) | 两数之和、数组去重 |
| **双指针** | O(n) | O(1) | 反转链表、合并链表 |
| **递归/回溯** | O(n!) | O(n) | 全排列、树遍历 |
| **排序** | O(n log n) | O(1) | 冒泡排序 |
| **二分查找** | O(log n) | O(1) | 二分查找 |
| **滑动窗口** | O(n) | O(k) | 无重复字符最长子串 |
| **动态规划** | O(n²) | O(n²) | 编辑距离 |
| **贪心** | O(n log n) | O(1) | 分发饼干 |

---

## 💡 学习建议

1. **理解思路**：掌握每种算法的核心思想
2. **手写代码**：能够手写实现，不要只看不练
3. **复杂度分析**：理解时间复杂度和空间复杂度
4. **举一反三**：掌握一类题目的通用解法

---

## 📖 相关资源

- [LeetCode 中文站](https://leetcode.cn/)
- [算法可视化](https://visualgo.net/)

---

**相关文件**：
- [算法手写题_汇总.md](./算法手写题_汇总.md) - 算法手写题集合
