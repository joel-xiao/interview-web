# 整体项目介绍

> 企业级数据可视化平台的整体架构介绍，包含前端、BFF 层、多数据源的完整技术架构

**文件位置**：`08-面试准备/项目经验/整体项目介绍.md`

**相关文档**：
- [大屏低代码介绍.md](./大屏低代码介绍.md) - 大屏低代码编辑平台介绍
- [项目架构设计.md](./项目架构设计.md) - 技术架构设计文档

---

## 📝 整体项目自我介绍（3-5分钟版本）

### 开场介绍

**面试官您好，我想介绍一下我负责的企业级数据可视化平台项目。**

这是一个完整的前后端分离的企业级数据可视化平台，采用 BFF 架构，包含前端 Dashboard、后端 Fusion BFF 层，以及多个数据源（PostgreSQL、Elasticsearch、Forerunner、NPM）。平台主要服务于业务部门的数据展示需求，支持应用监控、事务追踪、网络监控、大屏可视化等多个业务场景。

---

### 一、项目背景与技术选型

**首先说一下项目背景。**

这个项目是我们公司内部的企业级数据可视化平台，主要解决以下问题：
1. **多数据源聚合**：需要从多个后端数据源（PostgreSQL、Elasticsearch、Forerunner、NPM）获取数据
2. **数据格式不统一**：不同数据源的格式不一致，前端需要做大量适配工作
3. **接口复杂度高**：前端直接调用多个后端服务，维护困难
4. **安全控制分散**：需要在多个地方进行认证、鉴权、数据过滤

**所以我设计了 BFF 架构，核心思路是：**
- 前端（Dashboard）专注于用户界面和交互
- BFF 层（Fusion）作为数据聚合层，统一访问后端数据源
- 通过数据抽象层实现存储引擎透明切换
- 统一在 BFF 层进行认证、鉴权、数据过滤

**技术选型方面：**

**前端（Dashboard）：**
- **框架**：Vue3 + Vite，主要看中 Composition API 和性能优势
- **状态管理**：Vuex，统一管理全局状态
- **可视化库**：ECharts、Three.js、G6、Mapbox GL

**后端 BFF（Fusion）：**
- **运行时**：Node.js v16+
- **Web 框架**：Express.js
- **数据存储**：PostgreSQL（主存储）、Elasticsearch（可选）
- **认证授权**：JWT、Session、Casbin（RBAC）

**数据源：**
- **PostgreSQL**：主存储，用于配置数据、用户数据、Dashboard 配置
- **Elasticsearch**：可选存储，用于日志数据、监控指标
- **Forerunner**：上游服务，用于应用监控数据聚合
- **NPM**：网络监控服务，用于网络流量、拓扑数据

---

### 二、BFF 架构设计

**架构设计这块，我采用了 BFF（Backend For Frontend）架构。**

#### 1. 整体架构分层

**架构分层：**
- **前端层（Dashboard）**：Vue3 + Vite，负责用户界面和交互
- **BFF 层（Fusion）**：Node.js + Express，作为数据聚合层，统一访问后端数据源
- **数据源层**：PostgreSQL、Elasticsearch、Forerunner、NPM 等多个数据源

**为什么采用 BFF 架构？**

**遇到的问题：**
1. 前端需要从多个后端数据源获取数据（PostgreSQL、Elasticsearch、Forerunner、NPM）
2. 不同数据源的格式不一致，前端需要做大量适配工作
3. 接口复杂度高，前端直接调用多个后端服务，维护困难
4. 需要在统一层进行认证、鉴权、数据过滤

**BFF 架构的优势：**
- **数据聚合**：BFF 层聚合多个数据源，前端只需调用一个 API
- **格式统一**：BFF 层将不同数据源格式转换为前端所需格式
- **前端简化**：前端不需要关心后端数据源细节，代码更简洁
- **安全集中**：统一在 BFF 层进行认证、鉴权、数据过滤
- **前后端解耦**：前端与后端数据源解耦，数据源变更不影响前端

#### 2. Fusion BFF 层的设计

**我设计了五层架构：**

**第一层是接入层（Server Layer）：**
- HTTP 服务器启动
- 全局中间件加载（Helmet、BodyParser、CookieParser）
- Session 存储初始化（支持 ES 或 Memory Store）
- 静态资源托管
- 文件上传处理

**第二层是路由层（Routes Layer）：**
- **API v1**：稳定版本，1500+ 路由，向后兼容
  - 应用监控：`/api/v1/app/*`
  - 事务追踪：`/api/v1/transaction/*`
  - Dashboard：`/api/v1/dashboard/*`
  - 报表：`/api/v1/report/*`
  - 网络监控：`/api/v1/npm/*`
- **API v2**：新特性版本，优化接口设计
- **Web 路由**：Web 页面和 SSO 认证

**第三层是中间件层（Middleware Layer）：**
- **认证**：Session/JWT 验证
- **鉴权**：Casbin RBAC、SafeAPI 权限控制
- **租户隔离**：多租户数据隔离
- **请求预处理**：参数校验、请求拦截

**第四层是业务逻辑层（Business Logic Layer）：**
- 参数校验（Joi Schema）
- 业务逻辑处理
- 数据转换与格式化
- 错误处理

**第五层是数据抽象层（Data Abstraction Layer）：**
- `dbInterface.js`：统一数据访问接口
- 存储引擎透明切换
- 多数据源适配

#### 3. 数据抽象层的核心设计

**核心机制：通过 `dbInterface.js` 实现存储引擎透明切换**

**实现方式：**
```javascript
// src/data/dbInterface.js
const config = require('config');
const enablePgsql = config.get('pgsql.enable');

let dbImpl;
if (enablePgsql) {
  dbImpl = require('./backend/pgsql/dbImpl');
} else {
  dbImpl = require('./backend/elasticsearch/dbImpl');
}

const DBInterfaces = [{
  ...dbImpl
}];

module.exports = {
  DBInterfaces,
};
```

**这样设计的好处：**
- 存储引擎透明切换，便于迁移和扩展
- 统一的接口定义，降低复杂度
- 支持多数据源混合使用
- 业务层代码无需修改即可切换存储引擎

**数据适配器：**
- **PostgreSQL 适配器**（`backend/pgsql/`）：主存储，用于配置数据、用户数据、Dashboard 配置
- **Elasticsearch 适配器**（`backend/elasticsearch/`）：可选存储，用于日志数据、监控指标
- **Forerunner 适配器**（`backend/forerunner/`）：上游服务，用于应用监控数据聚合
- **NPM 适配器**（`backend/npm/`）：网络监控服务，用于网络流量、拓扑数据

#### 4. API 版本管理

**版本策略：**
- **API v1**：稳定版本，1500+ 路由，向后兼容
- **API v2**：新特性版本，优化接口设计

**路由注册：**
```javascript
// src/routes/index.js
function registerApiRoutes(app) {
  app.use('/api/v1', apiv1);  // 稳定版本
  app.use('/api/v2', apiv2);  // 新特性版本
  app.use('', web);            // Web 路由
}
```

#### 5. 认证与鉴权架构

**认证机制：**
- **Session 认证**：基于 `express-session`，支持 ES 或 Memory Store
- **JWT 认证**：基于 `jsonwebtoken`，用于 API 调用
- **SSO 认证**：支持 CAS、TAC、P13 等 SSO 协议

**鉴权机制：**
- **Casbin RBAC**：基于角色的访问控制
  - 策略管理：`src/common/acl/policy.js`
  - 权限验证：`src/common/acl/casbin.js`
- **SafeAPI**：API 级别的权限控制
  - API 权限配置：`src/common/safeapi/`
  - 权限拦截：`src/common/safeapi/index.js`

**多租户支持：**
- 租户隔离：数据按租户隔离
- 权限隔离：不同租户权限独立
- 数据隔离：租户数据完全隔离

---

### 三、前后端通信架构

#### 1. 前端服务层调用

**前端 Service 层设计：**
```javascript
// dashboard/src/service/dashboard.service.js
import helper from './helper';

function fetchDashboard(options = {}) {
  return helper.ajaxGet('dashboard', options).catch(r => []);
}

function updateDashboard(options = {}) {
  return helper.ajaxPost('dashboard', options).catch(r => []);
}
```

#### 2. 完整请求流程

**数据流向：**
```
前端组件
  ↓
Service 层 (service/dashboard.service.js)
  ↓
HTTP 请求 (Axios)
  ↓
Fusion BFF (端口: 6800)
  ↓
路由层 (/api/v1/dashboard/*)
  ↓
中间件层 (认证/鉴权)
  ↓
业务逻辑层 (参数校验、业务处理)
  ↓
数据抽象层 (dbInterface)
  ↓
数据源适配器 (PostgreSQL/ES/Forerunner)
  ↓
数据源
```

**数据获取流程（10 步）：**
1. **前端请求** → Service 层调用 `fetchDashboardScene(id)`
2. **HTTP 请求** → 发送到 `http://fusion:6800/api/v1/dashboard/scene/${id}`
3. **路由匹配** → Fusion 路由层匹配到对应 Controller
4. **中间件处理** → 认证、鉴权、参数校验
5. **业务逻辑** → Controller 处理业务逻辑
6. **数据访问** → 通过 `dbInterface` 访问数据源
7. **数据聚合** → 从 PostgreSQL、Forerunner 等多个数据源获取数据
8. **数据适配** → 将数据格式转换为前端所需格式
9. **响应返回** → 返回 JSON 数据给前端
10. **前端更新** → 前端接收数据，更新 Store 和视图

#### 3. 数据聚合与适配

**数据聚合场景：**
- **多源数据合并**：从 PostgreSQL、Elasticsearch、Forerunner 多个数据源获取数据并合并
- **数据格式转换**：将后端数据格式转换为前端所需格式
- **字段映射**：统一字段名称，适配前端组件需求

**适配器模式应用：**
```javascript
// Fusion 数据适配示例
async function fetchDashboardData(dashboardId) {
  // 1. 从 PostgreSQL 获取 Dashboard 配置
  let config = await dbImpl.getDashboardConfig(dashboardId);
  
  // 2. 从 Forerunner 获取监控数据
  let metrics = await forerunnerAdapter.getMetrics(config.metricIds);
  
  // 3. 从 Elasticsearch 获取日志数据（可选）
  let logs = await esAdapter.getLogs(config.logQuery);
  
  // 4. 数据聚合与格式转换
  return {
    config,
    metrics: adaptMetrics(metrics),
    logs: adaptLogs(logs)
  };
}
```

---

### 四、BFF 架构优势总结

#### 前端优势
- **接口统一**：前端只需调用 Fusion API，无需关心后端数据源
- **数据格式适配**：BFF 层完成数据格式转换，前端直接使用
- **减少前端复杂度**：业务逻辑在 BFF 层处理，前端更轻量

#### 后端优势
- **数据源解耦**：前端与后端数据源解耦，数据源变更不影响前端
- **性能优化**：BFF 层可以缓存、聚合数据，减少前端请求次数
- **安全控制**：统一在 BFF 层进行认证、鉴权、数据过滤

#### 架构优势
- **可扩展性**：新增数据源只需添加适配器，无需修改前端代码
- **可维护性**：前后端职责清晰，便于维护和迭代
- **团队协作**：前后端团队可以并行开发，通过 API 契约协作

---

### 五、技术栈总结

**前端技术栈：**
- **框架**：Vue3（Composition API + `<script setup>`）
- **状态管理**：Vuex
- **构建工具**：Vite
- **可视化库**：ECharts、Three.js、G6、Mapbox GL

**后端 BFF 技术栈：**
- **运行时**：Node.js v16+
- **Web 框架**：Express.js
- **数据存储**：PostgreSQL、Elasticsearch
- **ORM**：Sequelize（PostgreSQL）
- **认证授权**：JWT、Session、Casbin（RBAC）
- **数据验证**：Joi

**架构模式：**
- **BFF 架构**：前端 + BFF + 多数据源，实现数据聚合与接口适配
- **分层架构**：BFF 分层（接入层、路由层、中间件层、业务逻辑层、数据抽象层）
- **适配器模式**：多数据源适配，统一数据接口

---

## 🎯 面试要点总结

### 核心亮点
1. **BFF 架构**：前端 + BFF + 多数据源，实现数据聚合与接口适配，前后端解耦
2. **数据抽象层**：通过 `dbInterface.js` 实现存储引擎透明切换
3. **多数据源适配**：PostgreSQL、Elasticsearch、Forerunner、NPM 多数据源统一访问
4. **API 版本管理**：v1 稳定版本、v2 新特性版本
5. **认证鉴权**：Session、JWT、Casbin RBAC 多层级安全控制

### 技术深度
- **架构设计能力**：BFF 架构、分层架构、数据抽象层设计
- **后端能力**：Node.js + Express、数据抽象层设计、多数据源适配
- **前后端协作**：API 契约设计、前后端解耦、团队协作

### 解决问题能力
- **多数据源聚合**：BFF 架构解决多数据源聚合问题
- **数据格式统一**：BFF 层统一数据格式，前端简化
- **前后端解耦**：通过 API 契约实现前后端解耦
- **可扩展性**：数据抽象层支持存储引擎透明切换

---

## 💡 面试回答技巧

### 1. 项目背景（30秒）
- 简洁说明项目背景和解决的问题
- 突出 BFF 架构的价值和意义

### 2. BFF 架构设计（2-3分钟）
- **为什么采用 BFF 架构**：说明遇到的问题和架构优势
- **Fusion BFF 层的设计**：五层架构设计思路
- **数据抽象层**：说明数据抽象层的核心设计
- **多数据源适配**：说明适配器模式的应用

### 3. 前后端通信（1分钟）
- 说明完整的数据流向（10 步流程）
- 说明数据聚合与适配的实现

### 4. 架构优势（30秒）
- 用数据说明架构优势
- 突出项目的亮点和贡献

---

## 📌 常见面试问题准备

### Q1: 为什么采用 BFF 架构？
**回答要点：**
- 解决多数据源聚合问题：前端需要从 PostgreSQL、Elasticsearch、Forerunner、NPM 等多个数据源获取数据
- 数据格式统一：BFF 层将不同数据源格式转换为前端所需格式
- 前端简化：前端只需调用 Fusion API，无需关心后端数据源细节
- 安全集中：统一在 BFF 层进行认证、鉴权、数据过滤
- 前后端解耦：前端与后端数据源解耦，数据源变更不影响前端

### Q2: BFF 层的数据抽象层是如何设计的？
**回答要点：**
- 通过 `dbInterface.js` 实现存储引擎透明切换
- 支持 PostgreSQL 和 Elasticsearch 两种存储引擎
- 业务层代码无需修改即可切换存储引擎
- 统一的接口定义，支持多数据源混合使用
- 通过适配器模式实现不同数据源的统一访问

### Q3: 如何实现多数据源适配？
**回答要点：**
- 采用适配器模式
- 每个数据源都有对应的适配器（PostgreSQL、Elasticsearch、Forerunner、NPM）
- 统一的接口定义，屏蔽底层数据差异
- 数据格式转换、字段映射、数据清洗

### Q4: API 版本管理是如何实现的？
**回答要点：**
- API v1：稳定版本，1500+ 路由，向后兼容
- API v2：新特性版本，优化接口设计
- 通过路由层实现版本管理
- 支持新旧版本共存，平滑迁移

### Q5: 认证与鉴权是如何设计的？
**回答要点：**
- 认证机制：Session、JWT、SSO
- 鉴权机制：Casbin RBAC、SafeAPI
- 多租户支持：租户隔离、权限隔离、数据隔离
- 统一在中间件层进行认证、鉴权

---

## 🔗 相关文档

- [大屏低代码介绍.md](./大屏低代码介绍.md) - 大屏低代码编辑平台介绍
- [项目架构设计.md](./项目架构设计.md) - 技术架构设计文档

